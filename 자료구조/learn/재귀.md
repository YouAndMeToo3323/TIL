### 재귀함수
* 함수가 자신을 다시 호출하는 프로그래밍 기법으로서 문제를 더 작은 문제로 분할하여 해결하기 위해 사용한다.
* 기본구조
  * 기저 조건 : 재귀 호출을 멈추는 조건. 이 조건이 없으면 함수는 무한히 자신을 호출하게 되어 스택 오버플로우(Stack Overflow)를 일으킨다.
  * 재귀 호출 : 함수를 다시 호출하여 더 작은 문제로 분할하는 부분
* 장점
  * 문제를 더 작은 문제로 나누어 해결할 수 있어 코드가 직관적이고 이해하기 쉽다.
  * 특정 알고리즘(예: 하노이 탑, 탐색 알고리즘)에서 매우 유용
* 단점
  * 재귀 호출이 많아지면 함수 호출 스택이 커져 메모리 사용량이 증가(오버플로우).
  * 각 함수 호출에 대한 오버헤드(함수를 호출할때 함수 내용이 아닌 함수를 호출하는데 들어가는 비용(메모리와 시간))가 발생.
  * 기저 조건을 잘못 설정하면 무한 루프에 빠질 수 있다.
* 재귀함수의 최적화 - 메모이제이션(Memoization)
  * 이미 계산한 값을 저장하여 동일한 계산을 반복하지 않도록 할 수 있다.

#### 1. 팩토리얼(factorial)
* 팩토리얼 값을 반환하는 함수를 재귀적으로 구현

```cpp
/*
f(n) = { n * f(n-1)  ....n>=1  //정수 n이 1보다 크거나 같으면 n * f(n-1)을 반환
       {1            ....n=0  //정수 n이 0이면 1을 반환
*/
int Factorial(int n)
{
  if(n == 0)
    return 1;
  else
    return n * Factorial;
}
```
 
#### 2. 피보나치 수열(Fibonacci Sequence)
* 첫째 및 둘째 항이 1이며 그 뒤의 모든 항은 바로 앞 두 항의 합인 수열 또는 재귀적인 형태를 띠는 대표적인 수열

```cpp
/*
fib(n) = {0                       .... n = 1
         {1                       .... n = 2
         {fib(n-1) + fib(n-2)     .... otherwise
*/
int Fibo(int n)     //피보나치 수열의 n번째 값 반환(반환한 값을 모두 합산)
{
  if(n==1)          //피보나치 수열의 첫 번째 값을 요구하면
    return 0;
  else if(n==2)     //피보나치 수열의 두 번째 값을 요구하면
    return 1;
  else              //피보나치 수열의 셋 번째 이후의 값을 요구하면
    return Fibo(n-1) + Fibo(n-2);
}
```

#### 3. 이진 탐색 알고리즘(BinarySearch Algorithm)
```cpp
int BSearchRecur(int ar[], int first, int last, int target)
{
 int mid;
 if(first > last) //첫번째 인덱스 값(first)이 마지막 인덱스 값(last)보다 크면 탐색 실패(-1)
    return -1;
 mid = (first + last) /2; //탐색 대상의 중앙을 지정

 if(ar[mid] == target) //탐색 대상과 중앙값이 일치하면 탐색 종료(mid)
    return mid;
 else if(target < ar[mid])
    return BSearchRecur(ar, first, mid-1, target); //중앙값이 크면 last값 수정
 else
    return BSearchRecur(ar, mid+1, last, target); //중앙값이 작으면 first값 수정
}
```
