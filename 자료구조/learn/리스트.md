### 1. 추상 자료형 : Abstract Data Type
* 구현하고자 하는 구조에 대해 실제 구현 내용이 아닌 자료구조의 특성과 어떤 행동을 하는지 설명하는 타입 또는 클래스
* 구체적인 기능의 완성과정을 언급하지 않고, 순수하게 기능이 무엇인지를 나열 한 것.

### 2. 리스트
* 특징
  * 순서 유지 : 리스트는 요소들의 순서를 유지한다. 각 요소는 인덱스(순서 번호)를 가지고 있으며, 이를 통해 요소에 접근할 수 있다.
  * 동일한 데이터 타입 :  동일한 데이터 타입의 요소들을 저장한다.
  * 크기 가변성 : 리스트는 요소를 추가하거나 제거할 수 있어 크기가 유동적이다.
  * 빠른 인덱싱 : 인덱스를 통해 요소에 빠르게 접근할 수 있다.
* 리스트의 주요 연산
  1. 초기화 : 리스트를 사용하기 전에 리스트 구조를 초기화하고 필요한 메모리를 할당
  2. 삽입 : 리스트의 특정 위치에 요소를 추가
  3. 삭제 : 리스트의 특정 위치에 있는 요소를 제거
  4. 탐색 : 리스트에서 특정 요소를 탐색
  5. 조회 : 리스트의 특정 위치에 있는 요소를 반환
  6. 메모리 해제 : 리스트가 더 이상 필요 없을 때 할당된 메모리를 해제

* 구현방법
  * 배열 기반 리스트
  * 연결 리스트


#### 2-1. 배열 기반 리스트(순차리스트)
* 고정된 크기의 배열을 사용하여 요소를 저장하며, 배열이 가득 차면 더 큰 배열로 복사하여 확장한다.
* 장점
  * 데이터의 참조가 쉽다. 인덱스 값을 기준으로 어디든 한 번에 참조가 가능하다. (O(1))
* 단점
  * 배열의 길이가 초기에 결정되어야 한다. 확장이 필요할 경우, 동적할당이고 realloc함수를 이용하여 확장한다.
  * 요소 삽입과 삭제의 과정에서 데이터의 이동(복사 또는 재배치)가 매우 빈번히 일어난다. (O(n))

```cpp
//초기화
void ListInit(List* plist) 
{
	(plist->numOfData) = 0;				//리스트에 저장된 데이터의 수를 0으로 선언
	(plist->curPosition) = -1;			//배열은 0부터 시작하므로 위치값은 -1부터 시작
}

//삽입
void LInsert(List* plist, LData data) 
{
	if (plist->numOfData >= LIST_LEN) 
	{
		printf("저장이 불가능합니다.\n");
		return;
	}//저장소보다 데이터량이 클경우 함수 종료

	plist->arr[plist->numOfData] = data;		//배열에 데이터 저장
	(plist->numOfData)++;				//plist에 저장된 데이터의 수 증가
}

//삭제
LData LRemove(List* plist) 
{
	int rpos = plist->curPosition;			//plist의 현재 참조위치
	int num = plist->numOfData;			//plist의 현재 데이터의 수
	int i;
	LData rdata = plist->arr[rpos];

	for (i = rpos; i < num - 1; i++) 
	{
		plist->arr[i] = plist->arr[i + 1];	//plist의 현재 데이터를 한 칸씩 이동
	}
	(plist->curPosition)--;				//plist의 현재 참조위치 삭제
	(plist->numOfData)--;				//plist의 현재 데이터의 수 삭제

	return rdata;
}

//탐색 및 조회
int LFirst(List* plist, LData* pdata) //첫 데이터 참조
{
	if (plist->numOfData == 0)			//plist에 데이터가 없을 경우(0)
		return FALSE;

	(plist->curPosition) = 0;			//plist의 참조위치는 0
	*pdata = plist->arr[plist->curPosition];	//plist의 참조위치에 해당하는 데이터 출력
	return TRUE;
}
int LNext(List* plist, LData* pdata) 	//두 번째 이후 데이터 참조
{
	if (plist->curPosition >= plist->numOfData - 1)	//plist의 현재 참조위치보다 현재 저장된 데이터의 수가 적으면(참조위치가 0부터 시작하므로 데이터의수 -1)
		return FALSE;

	(plist->curPosition)++;				//plist의 참조위치 증가
	*pdata = plist->arr[plist->curPosition];	//plist의 참조위치에 해당하는 데이터 출력
	return TRUE;
}
```

#### 2-2. 연결 리스트
* 각 요소가 노드로 구현되며, 노드는 데이터와 다음 노드에 대한 참조(포인터)를 가진다.
* 장점
  * 요소의 삽입과 삭제가 빠르다. (O(1))
* 단점
  * 인덱스를 통한 접근이 느리다. (O(n))









