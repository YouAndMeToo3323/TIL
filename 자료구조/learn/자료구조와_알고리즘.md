### 1. 자료구조
데이터를 표현하고 저장하는 방법에 대해서 알려준다.

#### 1-1. 자료구조의 분류



### 2. 알고리즘
* 표현 및 저장된 데이터를 대상으로 하는 '문제의 해결 방법'을 뜻한다.
* 알고리즘의 수행속도를 평가할 때는 **'처리해야 할 데이터의 수n에 대한 연산횟수의 함수 T(n)'** 으로 평가한다.
* 알고리즘을 평가하는 두 가지 요소
  * 시간 복잡도(Time Complexity) : 속도에 해당하는 알고리즘의 수행시간 분석결과
  * 공간 복잡도(Space Complexity) : 메모리 사용량에 대한 분석결과
* 알고리즘을 평가할 때 사용하는 케이스
  * 최선의 경우(best case) : 처리해야 할 데이터의 수n에 대한 연산횟수가 가장 작은 경우
  * 최악의 경우(worst case) : 처리해야 할 데이터의 수n에 대한 연산횟수가 n일 경우
  * 평균적인 경우(average case) : 시간 복잡도를 평가하는 정보로 의미를 지니지만, 대부분의 경우에는 알고리즘의 성능을 평가할 때 알고리즘의 안전성과 예측가능성을 보장해주는 **"최악의 경우 시간 복잡도"** 를 주로 사용

#### 2-1. 순차 탐색 알고리즘의 시간 복잡도 : 최악의 경우(worst case)
* 최악의 경우의 연산회수는 탐색 대상이 배열에 존재하는 않을 경우이다.(n)
```
T(n) = n	//최악의 경우를 대상으로 정의하는 함수 T(n)(데이터 수 n에 대한 연산횟수의 함수)
```

#### 2-2. 순차 탐색 알고리즘의 시간 복잡도 : 평균적인 경우(average case)
* 평균적인 경우의 연산회수 계산을 위해서는 
  * 가정 1. 탐색 대상이 배열에 존재하지 않을 확률을 50%라고 가정(n)
  * 가정 2. 배열의 첫 요소부터 마지막 요소까지, 탐색 대상이 존재할 확률은 동일하다는 가정(탐색 대상이 존재한다와 존재하지 않는다 50%, n/2)
* **평균적인 경우의 시간 복잡도 함수는 신뢰도가 높지 않고 두 개의 가정을 뒷받침할 근거가 부족하기 때문에** 최악의 경우의 시간 복잡도의 기준으로 삼는다. 

```
T(n) = n * 3/4 	//가정1에 대한 연산횟수 50%( n * 1/2) + 가정2에 대한 연산횟수 50%( n/2 * 1/2)
```

#### 2-3. 이진 탐색(Binary Search) 알고리즘
* 이진 탐색 알고리즘은 탐색의 대상을 반복해서 반씩 떨구어 내는 알고리즘으로서 정렬된 데이터가 아니면 적용이 불가능하다.
* 탐색 대상에 대한 시작 위치가 마지막 위치보다 큰 경우 탐색을 종료한다(탐색 실패).

```cpp
int BSearch(int ar[], int len, int target) //이진 탐색 함수
{
 int first = 0;	//탐색 대상의 시작 인덱스 값
 int last = len -1;	//탐색 대상의 마지막 인덱스 값
 int mid;	//탐색 대상에 대한 값

 while(first <= last)
 {
  mind = (first + last) / 2;	//탐색 대상 중앙값 지정

  if(target == ar[mid]	//탐색 대상과  타켓이 일치하면
  {
   return mid;	//탐색 대상을 반환
  }
  else
  {
   if(target < ar[mid])	//탐색 대상이 타겟보다 작으면 
    last = mid - 1;
   else	//탐색 대상이 타겟보다 크면
    first = mid + 1;
  }
 }
 return - 1;	//찾지 못했을 때 반환되는 값 -1
}
```

* **이진탐색알고리즘의 시간 복잡도 : 최악의 경우**
  * 데이터의 수가 n일 때, 최악의 경우에 발생하는 비교연산의 횟수
    * 1. n이 1이 되기까지 2로 나눈 횟수 k회 이므로 비교연산은 k회 진행 
    * 2. 데이터가 1개 남았을 때 마지막으로 비교연산 1회 진행

```
최악의 경우에 대한 시간 복잡도 함수 T(n) = k + 1

/*
n이 1이 되기까지 2로 나눈 횟수 : n * (1/2)^k = 1 --> n * 2^(- k) = 1 --> n = 2^(k) --> log2(n) = k
n에 대한 식 T(n)을 구성하는 목적은 데이터 수의 증가에 따른 연산횟수의 변화 정도를 판단하는 것이므로 
log2(n)의 값이 매우 커서 +1이 중요하지 않다.(빅-오 표기법과 같은 이유)
*/

최악의 경우에 대한 시간 복잡도 함수 T(n) = log2(n)
```

#### 3. 빅-오 표기법(Big-Oh Notation)
* 빅-오는 알고리즘의 효율성을 나타내기 위해 사용되는 수학적 표기법으로서 알고리즘의 실행 시간 또는 메모리 사용량이 입력 크기(데이터 수)에 따라 어떻게 변하는지 표기한다.
* 빅오 표기법은 최악의 경우 성능을 나타내며 알고리즘의 성능을 평가하고 비교하는 데 중요한 도구로 사용
* T(n)이 다항식으로 표현이 되는경우 최고차항의 차수가 빅-오가 된다(T(n) = n^2 + 2n + 1).

#### 3-1. 빅-오 종류
**1. O(1) - 상수 시간 (Constant Time)** <br/>
입력크기(데이터 수)에 상관없이 항상 일정한 시간이 걸리는(연산횟수가 고정인) 유형의 알고리즘<br/>
ex : 배열의 첫 번째 요소에 접근하기, 두 개의 숫자를 더하기

**2. O(logn) - 로그 시간 (Logarithmic Time)** <br/>
입력크기(데이터 수의 증가율)에 비해서 실행 시간(연산횟수의 증가율)이 휠씬 낮은 로그 형태의 알고리즘<br/>
ex : 이진 탐색(Binary Search)

**3. O(n) - 선형 시간 (Linear Time)** <br/>
입력 크기에 비례하여 실행 시간이 증가하는 알고리즘<br/>
ex : 배열에서 특정 값을 찾기

**4. O(n log n) - 선형 로그 시간 (Linearithmic Time)** <br/>
입력 크기가 증가할수록 실행 시간이 n과 log n의 곱으로 증가하는 알고리즘<br/>
ex : 합병 정렬(Merge Sort), 퀵 정렬(Quick Sort)

**5. O(n^2) - 이차 시간 (Quadratic Time)** <br/>
입력 크기에 따라 실행 시간이 n의 제곱에 비례하여 증가하는 알고리즘<br/>

ex : 버블 정렬(Bubble Sort), 삽입 정렬(Insertion Sort)





















