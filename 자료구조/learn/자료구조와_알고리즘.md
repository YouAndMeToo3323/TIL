### 자료구조와 알고리즘

#### 1. 자료구조
데이터를 표현하고 저장하는 방법에 대해서 알려준다.

##### 1-1. 자료구조의 분류



#### 2. 알고리즘
* 표현 및 저장된 데이터를 대상으로 하는 '문제의 해결 방법'을 뜻한다.
* 알고리즘을 평가하는 두 가지 요소로 **'시간 복잡도(Time Complexity)'는 속도에 해당하는 알고리즘의 수행시간 분석결과**를, **'공간 복잡도(Space Complexity)'는 메모리 사용량에 대한 분석결과**를 가리켜 말한다.
* 알고리즘의 수행속도를 평가할 때는 **'처리해야 할 데이터의 수n에 대한 연산횟수의 함수 T(n)'** 으로 평가한다.
* 모든 알고리즘에는 **'최선의 경우(best case)'** 와 **'최악의 경우(worst case)'**, **'평균적인 경우(average case)'** 가 각각 존재한다.
* '최선의 경우'는 처리해야 할 데이터의 수n에 대한 연산횟수가 가장 작은 경우를, '최악의 경우'는 처리해야 할 데이터의 수n에 대한 연산횟수가 n일 경우를 말한다.
* **'평균적인 경우'** 는 시간 복잡도를 평가하는 정보로 의미를 지니지만, 대부분의 경우에는 알고리즘의 성능을 평가할 때 알고리즘의 안전성과 예측가능성을 보장해주는 **"최악의 경우 시간 복잡도"** 를 주로 사용한다.

##### 2-1. 순차 탐색 알고리즘의 시간 복잡도 : 최악의 경우(worst case)
* 최악의 경우의 연산회수는 탐색 대상이 배열에 존재하는 않을 경우이다.(n)
```
T(n) = n	//최악의 경우를 대상으로 정의하는 함수 T(n)(데이터 수 n에 대한 연산횟수의 함수)
```

##### 2-2. 순차 탐색 알고리즘의 시간 복잡도 : 평균적인 경우(average case)
* 평균적인 경우의 연산회수 계산을 위해서는 
  * 가정 1. 탐색 대상이 배열에 존재하지 않을 확률을 50%라고 가정(n)
  * 가정 2. 배열의 첫 요소부터 마지막 요소까지, 탐색 대상이 존재할 확률은 동일하다는 가정(탐색 대상이 존재한다와 존재하지 않는다 50%, n/2)
* **평균적인 경우의 시간 복잡도 함수는 신뢰도가 높지 않고 두 개의 가정을 뒷받침할 근거가 부족하기 때문에** 최악의 경우의 시간 복잡도의 기준으로 삼는다. 

```
T(n) = n * 3/4 	//가정1에 대한 연산횟수 50%( n * 1/2) + 가정2에 대한 연산횟수 50%( n/2 * 1/2)
```

##### 2-3. 이진 탐색(Binary Search) 알고리즘
* 이진 탐색 알고리즘은 탐색의 대상을 반복해서 반씩 떨구어 내는 알고리즘으로서 정렬된 데이터가 아니면 적용이 불가능하다.
* 탐색 대상에 대한 시작 위치가 마지막 위치보다 큰 경우 탐색을 종료한다(탐색 실패).

```cpp
int BSearch(int ar[], int len, int target) //이진 탐색 함수
{
 int first = 0;	//탐색 대상의 시작 인덱스 값
 int last = len -1;	//탐색 대상의 마지막 인덱스 값
 int mid;	//탐색 대상에 대한 값

 while(first <= last)
 {
  mind = (first + last) / 2;	//탐색 대상 중앙값 지정

  if(target == ar[mid]	//탐색 대상과  타켓이 일치하면
  {
   return mid;	//탐색 대상을 반환
  }
  else
  {
   if(target < ar[mid])	//탐색 대상이 타겟보다 작으면 
    last = mid - 1;
   else	//탐색 대상이 타겟보다 크면
    first = mid + 1;
  }
 }
 return - 1;	//찾지 못했을 때 반환되는 값 -1
}
```

* **이진탐색알고리즘의 시간 복잡도(최악의 경우를 기준으로)**
  * 데이터의 수가 n일 때, 최악의 경우에 발생하는 비교연산의 횟수
    * 1. n이 1이 되기까지 2로 나눈 횟수 k회 이므로 비교연산은 k회 진행 
    * 2. 데이터가 1개 남았을 때 마지막으로 비교연산 1회 진행

```
최악의 경우에 대한 시간 복잡도 함수 T(n) = k + 1

/*
n이 1이 되기까지 2로 나눈 횟수 : n * (1/2)^k = 1 --> n * 2^(- k) = 1 --> n = 2^(k) --> log2(n) = k
n에 대한 식 T(n)을 구성하는 목적은 데이터 수의 증가에 따른 연산횟수의 변화 정도를 판단하는 것이므로 
log2(n)의 값이 매우 커서 +1이 중요하지 않다.(빅-오 표기법과 같은 이유)
*/

최악의 경우에 대한 시간 복잡도 함수 T(n) = log2(n)
```










