### 1. 동적 계획법(Dynamic Programming, DP)
* 복잡한 문제를 단순한 하위 문제로 나누어 해결하는 알고리즘 설계 기법
* 중복된 계산을 피하고 효율성을 높이기 위해 하위 문제의 결과를 저장하고 재사용하여, 주로 최적화 문제를 해결하는 데 사용
* **특성**
  * 최적 부분 구조(Optimal Substructure)
    * 문제의 최적 해결 방법이 하위 문제의 최적 해결 방법으로 구성될 수 있는 경우, DP를 사용
    * 예시) 최단 경로 문제에서 '특정 지점까지의 최단 경로' == '이전 지점까지의 최단 경로' + '현재 지점으로 가는 경로'
  * 중복 부분 문제(Overlapping Subproblems)
    * 문제를 해결하는 과정에서 동일한 하위 문제가 반복해서 나타나는 경우, DP를 사용하면 효율성을 높일 수 있다.
    * 예시) 피보나치 수열에서 F(n) = F(n-1) + F(n-2)와 같이 동일한 하위 문제(F(n-1)와 F(n-2))가 여러 번 계산

#### 2. 동적 계획법의 두가지 접근 방식
##### 2-1. 탑다운 접근법(Top-Down Approach, [메모이제이션](https://github.com/YouAndMeToo3323/TIL/blob/main/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/learn/%EC%9E%AC%EA%B7%80.md#5-%EB%A9%94%EB%AA%A8%EC%9D%B4%EC%A0%9C%EC%9D%B4%EC%85%98memoization))
* 재귀를 사용하여 문제를 상위에서 하위로 해결
* 각 하위 문제의 결과를 메모리에 저장하여, 동일한 하위 문제가 다시 나타날 때 저장된 결과를 사용
```cpp
//피보나치 수열 (메모이제이션을 이용한 재귀)



```

##### 2-2. 바텀업 접근법(Bottom-Up Approach)
* 반복문을 사용하여 하위 문제부터 상위 문제로 차례대로 해결
* 하위 문제의 결과를 배열 등에 저장하여, 상위 문제를 해결할 때 이를 참조

```cpp
//피보나치 수열 (반복문을 이용한 DP)





```

#### 3. 동적 계획법의 예시 문제들
##### 3-1. 피보나치 수열
* F(n) = F(n-1) + F(n-2)의 형태로 하위 문제들이 반복
* 중복 계산을 피하기 위해 메모이제이션 또는 바텀업 방식 사용


##### 3-2. 최장 공통 부분 수열(Longest Common Subsequence, LCS)
* 두 문자열의 최장 공통 부분 수열을 찾는 문제
* 두 문자열의 길이가 m과 n일 때, O(mn)의 시간 복잡도를 가짐


##### 3-3. 배낭 문제(Knapsack Problem)
* 제한된 무게 내에서 최대 가치를 가지는 물건을 고르는 문제
* 0/1 배낭 문제와 무한 배낭 문제로 나뉨



##### 3-4. 최단 경로 문제(Shortest Path Problem)
* 그래프에서 두 정점 간의 최단 경로를 찾는 문제
* 다익스트라 알고리즘과 플로이드-워셜 알고리즘 등이 있음



