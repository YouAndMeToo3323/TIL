## 선행처리와 매크로

### 선행처리
* 선행처리란 실행 파일을 생성하는 과정에서 소스 파일 내에 존재하는 선행처리 지시문을 처리하는 작업을 의미한다.
* #문자로 시작하는 선행처리문을 이용하여 소스코드의 일부를 수정한다(단순 치환).
* 이러한 선행처리 작업은 컴파일하기 전 선행처리기(preprocessor)에 의해 먼저 처리된다.
* 선행처리기는 코드를 생성하는 것이 아니라, 컴파일러가 컴파일하기 좋도록 소스를 재구성해 주는 역할만을 한다.

#### 선행처리문의 특징
* 선행처리문은 선행처리 문자(#)로 시작한다.
* 코드 내에서 하나의 라인을 모두 차지하며, 선행처리문 뒤에 C언어 코드를 추가하여 같이 사용할 수 없다.
* 다른 C언어의 명령문과는 달리 맨 뒤에 세미콜론(;)을 붙이지 않는다.
* 소스 파일 어디에나 위치할 수 있지만, 선행처리문이 위치한 곳에서부터 파일의 끝까지만 영향을 미친다.

#### 선행처리 지시자(preprocessing directives)
전처리기가 실행되면 각 코드는 파일에서 지시자를 찾는다. 지시자는 #으로 시작해서 줄바꿈(개행)으로 끝나는 코드를 뜻한다.

|선행처리 지시자|설명|
|:--:|:--|
|#include|외부에 선언된 함수나 상수 등을 사용하기 위해, 함수나 상수가 포함된 외부 파일을 현재 파일에 포함할 때 사용|
|#define|함수나 단순화해주는 매크로를 정의할 때 사용|
|#undef|#define 지시자로 이미 정의된 매크로를 삭제할 때 사용|
|#line|__LINE__매크로와 __FILE__매크로를 재정의할 때 사용|
|#error|지정한 오류 메시지를 출력하고, 컴파일 과정을 중단하고자 할 때 사용|
|#pragma|프로그램의 이식성을 위해 운영체제별로 달라지는 지시사항을 컴파일에 전달할 때 사용|
|#if, #ifdef, #ifndef,<br>#elif, #else, #endif|조건부 컴파일 지시자|

#### #include
* #include 지시자는 외부에 선언된 함수나 상수 등을 사용하기 위해서 헤더 파일을 현재 파일에 포함할 때 사용.
* 선행처리기는 #include 지시자 뒤에 나오는 파일 이름을 보고 해당 파일을 찾아서 그 내용을 현재 파일에 포함해준다.

* #include 문에서 파일 이름을 표시하는 방법
	* #include <stdio.h>
		* C언어에서 제공하는 표준 헤더 파일을 포함할 때에는 보통 꺾쇠괄호(<>)를 사용.
		* 꺾쇠괄호를 사용하여 파일 이름을 표시하면 선행처리기는 가장 먼저 표준 시스템 디렉터리에서 파일 이름에 해당하는 헤더 파일을 찾는다.
		* 하지만 표준 시스템 디렉터리에서 파일 이름에 해당하는 헤더 파일을 찾지 못하면 현재 작업 디렉터리도 검색한다.

	* #include "myStdio.h"
		* 사용자가 직접 작성한 헤더 파일을 포함할 때에는 보통 큰따옴표("")를 사용.
		* 큰따옴표를 사용하여 파일 이름을 표시하면 선행처리기는 가장 먼저 현재 작업 디렉터리에서 파일 이름에 해당하는 헤더 파일을 찾는다.
		* 하지만 파일 이름에 해당하는 헤더 파일을 찾지 못하면 표준 시스템 디렉터리도 검색한다.
  		* 드라이버 명과 디렉터리 경로를 포함하는 '절대경로(완전경로)'를 명시해서 헤더 파일을 지정할 수 있다.
   		* 하지만 절대경로를 지정해서 헤더파일을 선언하면 다른 컴퓨터에서 컴파일 하는 일이 매우 번거로워진다.

#### #define
* #define 지시자는 함수나 상수를 단순화해주는 매크로를 정의할 때 사용.
* 매크로는 함수나 상수에 이름을 붙임으로써, 해당 매크로가 무엇을 가리키고 있는지를 명확하게 나타내준다.
* 선행처리기는 #define 선행처리 지시문의 식별자를 단순히 대체 리스트(replacement-list)로 치환. 이러한 과정을 매크로 확장(macro expansion)이라고 한다.
* 매크로 이름인 식별자는 C언어의 변수 이름 생성 규칙과 똑같은 생성 규칙을 따라서 작성.
* 매크로 이름 중간에는 공백을 넣을 수 없지만, 실제값은 공백을 가질 수 있다. 또한, 매크로끼리 중첩하여 사용할 수 있다.

##### 1. 매크로 상수(오브젝트와 유사한 매크로(#define : Object-like macro))
* 매크로의 이름은 식별자가 매크로라는 사실을 부각시키기 위해 대문자로 정의한다.

```cpp
//지시자	매크로(식별자)	매크로 몸체(대체리스트)
#define		PI		3.1415			//매크로 PI를 매크로 몸체 3.1415로 전부 치환
```

##### 2. 매크로 함수(함수와 유사한 매크로(#define : Function-like macro))
* C언어에서는 #define 문에 인수로 함수의 정의를 전달함으로써 함수처럼 동작하는 매크로(매크로 함수)를 만들 수 있다.
* 매크로를 두 줄 이상에 걸쳐서 정의할 때에는 \문자를 활용해서 줄바꿈을 한다.

```cpp
//SQUARE(X) 입력 시 X*X형태로 전환(X는 매개변수)
#define SQUARE(X) ((X) * (X))	

//매크로를 줄바꿈
#define SQUARE(Y)  \ 
    ((Y) * (Y))	

/*잘못된 예시
//전달인자에 괄호를 안할 경우
SQUARE(3+2);	//3+2*3+2 = 11, 의도한 값 : 25

//전체 괄호를 안할 경우
int num = 120 / SQUARE(2);	// 120 / (2) * (2) = 120, 의도한 값 : 30
*/
```

##### 매크로 함수 사용 시 주의사항
* 매크로 함수의 전체를 괄호(())로 감싸야 한다.
* 매크로 함수의 인수들도 각각 괄호로 감싸야 한다.
* 매크로 함수를 호출할 때에는 증감 연산자(++, --)나 복합 대입 연산자 등은 사용하지 않는 것이 좋다.

##### 매크로 함수의 장점
* 매크로 함수는 단순 치환만을 해주므로, 인수의 타입을 신경 쓰지 않는다.
* 매크로 함수를 사용하면 여러 개의 명령문을 동시에 포함할 수 있다.
* 함수 호출에 의한 성능 저하가 일어나지 않으므로, 프로그램의 실행속도가 향상된다.

##### 매크로 함수의 실행속도가 빠른 이유
* 호출된 함수를 위한 스택 메모리의 할당
* 실행위치의 이동과 매개변수로의 인자 전달
* return 문에 의한 값의 반환

##### 매크로 함수의 단점
* 원하는 결과를 얻는 정확한 매크로 함수의 구현은 어려우며, 따라서 디버깅 또한 매우 어렵다.
* 매크로 함수의 크기가 증가하면 증가할수록 사용되는 괄호 또한 매우 많아져서 가독성이 떨어진다.
 
#### 조건부 컴파일(conditional compile)
* 조건부 컴파일을 사용하면 지정한 조건에 따라 코드의 일정 부분을 컴파일할지 안 할지를 지정할 수 있다.
* C언어의 조건문과는 달리 #endif 지시자를 사용하여 반드시 조건부 컴파일의 끝을 명시해야 한다.

##### 1.#if
* #if 지시자 다음에 나오는 조건식1의 결과가 0이 아니면 참, 0이면 거짓으로 간주
* 참이라면 #endif 사이에 있는 컴파일할 코드를 삽입, 거짓이면 통과
* #endif 지시자는 앞에 있는 조건부 컴파일을 닫는다.

```cpp
#include <stdio.h>
#define ADD	1
#define MIN	0

int main()
{
#if ADD		//ADD가 참이라면 #endif 사이에 있는 컴파일할 코드를 삽입, 거짓이면 통과
    	...
#endif
#if MIN		//MIN가 참이라면 #endif 사이에 있는 컴파일할 코드를 삽입, 거짓이면 통과
    	...
#endif
    
	return 0;
}
```

##### 2.#ifdef, #ifndef
* #ifdef 지시자는 매크로가 정의되어 있다면 해당 매크로의 값에 상관없이 컴파일할 코드를 삽입한다.
* #ifndef 지시자는 매크로가 정의되어 있지 않다면 해당 매크로의 값에 상관없이 컴파일할 코드를 삽입한다(#ifndef의 중간에 있는 n은 not을 의미).
* #ifdef..#endif과 #ifndef..#endif 매크로는 헤더파일의 중복포함 및 선언을 막기 위해 주로 사용한다.

```cpp
#include <stdio.h>
//#define ADD 1
#define MIN 0

int main()
{
    #ifdef ADD		//ADD가 정의되어 있지않으므로 #endif 사이에 있는 컴파일할 코드를 통과
        ...
    #endif
    #ifdef MIN		//MIN이 정의되어 있으므로 #endif 사이에 있는 컴파일할 코드를 삽입
        ...
    #endif
    
    #ifndef ADD		//ADD가 정의되어 있지않으므로 #endif 사이에 있는 컴파일할 코드를 삽입
        ...
    #endif
    #ifndef MIN		//MIN이 정의되어 있으므로 #endif 사이에 있는 컴파일할 코드를 통과
        ...
    #endif
    
	return 0;
}
```
##### 3.#else, #elif
* if 문에 else를 추가할 수 있듯이 #if, #ifdef, #ifndef 문에 #else 지시자를 사용하여 모든 조건에 해당하지 않는 경우를 지정할 수 있다.
* #if문에 else if를 여러 번 추가할 수 있듯이, #if문에 #elif 지시자를 사용하여 조건식을 여러 개 사용할 수 있다.
* #elif의 끝을 #else로 마무리 할 수 있다.

```cpp
#include <stdio.h>
#define HIT_NUM 7

int main()
{
#if HIT_NUM==5
	puts("매크로 상수 HIT_NUM은 현재 5입니다.");
#elif HIT_NUM==6
	puts("매크로 상수 HIT_NUM은 현재 6입니다.");
#elif HIT_NUM==7
	puts("매크로 상수 HIT_NUM은 현재 7입니다.");
#else
	puts("매크로 상수 HIT_NUM은 5, 6, 7이 아닙니다.");
#endif

	return 0;
}
```

#### #연산자
* #연산자는 치환의 결과를 문자열로 구성하는 연산자로서, 매크로 함수의 대체 리스트 안의 인수 앞에 사용하여 토큰을 문자열로 변환시켜준다.
* 토큰이란 의미를 구성하는 최소 단위로서 식별자나 키워드를 토큰이라고도 부른다.
* 해당 토큰은 실인수로 치환되면서 양쪽에 위치한 큰따옴표("")를 포함해 그대로 문자열 상수로 치환된다.
* 문자열 안에 #연산자를 사용하면 매크로 함수로 전달된 인수를 포함시킬 수 있으며, 문자열이 나란히 선언되면 하나의 문자열로 간주한다.

```cpp
#include <stdio.h>
#define SQR(X) printf(""#X"의 제곱은 %d입니다.\n", ((X)*(X)))
#define STRING_JOB(A,B)	#A "의 직업은 "	#B "입니다."	//"A""의 직업은 ""B""입니다." -> "A의 직업은 B입니다."

int main()
{
	int x = 5;
	
	/*
	printf  (  "Height: %d\n"  ,    height  )  ;	//7개의 토큰으로 구성
	*/

	SQR(x);		//""x"의 제곱은 "25"입니다."	->	"x의 제곱은 25입니다."
	SQR(3+4);	//""3+4"의 제곱은 "49"입니다."	->	"3+4의 제곱은 49입니다."

	printf("%s \n",STRING_JOB(철수,학생));		//"철수의 직업은 학생입니다."
	printf("%s \n",STRING_JOB(영희,선생님));	//"영희의 직업은 선생님입니다."


	return 0;
}
```

#### ##연산자
* ##연산자는 두 개의 토큰을 하나의 토큰으로 결합해 주는 선행처리기 연산자로서 함수 같은 매크로뿐만 아니라 객체 같은 매크로의 대체 리스트에도 사용할 수 있다.
* 이 연산자를 사용하면 변수나 함수의 이름을 프로그램의 런타임에 정의할 수 있다.

```cpp
#include <stdio.h>
#define XN(n) x ## n	//x ## n -> xn

int main(void)
{
	int XN(1) = 10;
	int XN(2) = 20;

	printf("x1에 저장된 값은 %d입니다.\n", x1);	//x1에 저장된 값은 10입니다.
	printf("x2에 저장된 값은 %d입니다.\n", x2);	//x2에 저장된 값은 20입니다.

	return 0;
}
```













