## 선행처리와 매크로

### 선행처리
* 컴파일 이전의 처리를 의미하며, #문자로 시작하는 선행처리문을 이용하여 소스코드의 일부를 수정한다(단순 치환).
* 선행처리 명령문은 #문자로 시작을 하며, 컴파일러가 아닌 선행처리기에 의해서 처리되는 문장이기 때문에 명령문의 끝에 세미콜론을 붙이지 않는다.
* 선행처리기에 의해서 변환되는 과정 자체를 가리켜 '매크로 확장(macro expansion)'이라 한다.

#### 대표적인 선행처리 명령문

##### 1. 매크로 상수(젝트와 유사한 매크로(#define : Object-like macro))
* 매크로의 이름은 식별자가 매크로라는 사실을 부각시키기 위해 대문자로 정의한다.

```cpp
//지시자 매크로 매크로 몸체
#define  PI     3.1415		//매크로 PI를 매크로 몸체 3.1415로 전부 치환
```

##### 2. 매크로 함수(함수와 유사한 매크로(#define : Function-like macro))
* 매크로 함수는 정의할 때에는 매크로의 몸체부분을 구성하는 X와 같은 전달인자 전부 괄호를 해야 하고, 반드시 전체를 괄호로 한번 더 묶어줘야 한다.
* 매크로를 두 줄 이상에 걸쳐서 정의할 때에는 \문자를 활용해서 줄바꿈을 한다.

```cpp
//SQUARE(X) 입력 시 X*X형태로 전환(X는 매개변수)
#define SQUARE(X) ((X) * (X))	

//매크로를 줄바꿈
#define SQUARE(Y)  \ 
    ((Y) * (Y))	

/*잘못된 예시
//전달인자에 괄호를 안할 경우
SQUARE(3+2);	//3+2*3+2 = 11, 의도한 값 : 25

//전체 괄호를 안할 경우
int num = 120 / SQUARE(2);	// 120 / (2) * (2) = 120, 의도한 값 : 30
*/
```

* **매크로 함수의 장점**
    * 매크로 함수는 일반 함수에 비해 실행속도가 빠르다.
    * 자료형에 따라서 별도로 함수를 정의하지 않아도 된다.

* **매크로 함수의 단점**
    * 정의하기가 정말로 까다롭다.
    * 디버깅하기가 쉽지 않다.
    
* **매크로 함수의 실행속도가 빠른 이유**
    * 호출된 함수를 위한 스택 메모리의 할당
    * 실행위치의 이동과 매개변수로의 인자 전달
    * return 문에 의한 값의 반환

#### 조건부 컴파일을 위한 매크로

##### 1.참이라면(#if... #endif)
* #if...#endif는 조건부 컴파일을 제어하는 전처리기 지시문으로서, #if는 지정된 기호가 정의된 경우에만 코드가 컴파일되는 조건부 컴파일을 실행하고 #endif는 앞에 있는 조건부 컴파일을 닫는다.
```cpp
#include <stdio.h>
#define ADD	1
#define MIN	0

int main()
{
...
...


#if ADD		//ADD가 '참'이라면 #endif 사이에 있는 코드를 삽입, 거짓이면 삭제
    ...
#endif

#if MIN		//MIN가 '참'이라면 #endif 사이에 있는 코드를 삽입, 거짓이면 삭제
    ...
#endif

return 0;
}
```

##### 2.정의되었다면(#ifdef... #endif)

```cpp

```

##### 2.정의되었다면(#ifndef... #endif)

```cpp

```









