## 선행처리와 매크로

### 선행처리
* 선행처리란 실행 파일을 생성하는 과정에서 소스 파일 내에 존재하는 선행처리 지시문을 처리하는 작업을 의미한다.
* #문자로 시작하는 선행처리문을 이용하여 소스코드의 일부를 수정한다(단순 치환).
* 이러한 선행처리 작업은 컴파일하기 전 선행처리기(preprocessor)에 의해 먼저 처리된다.
* 선행처리기는 코드를 생성하는 것이 아니라, 컴파일러가 컴파일하기 좋도록 소스를 재구성해 주는 역할만을 한다.

#### 선행처리문의 특징
* 선행처리문은 선행처리 문자(#)로 시작한다.
* 선행처리문은 코드 내에서 하나의 라인을 모두 차지하며, 선행처리문 뒤에 C언어 코드를 추가하여 같이 사용할 수 없다.
* 선행처리문은 다른 C언어의 명령문과는 달리 맨 뒤에 세미콜론(;)을 붙이지 않는다.
* 행처리문은 소스 파일 어디에나 위치할 수 있지만, 선행처리문이 위치한 곳에서부터 파일의 끝까지만 영향을 미친다.

#### 선행처리 지시자(preprocessing directives)
전처리기가 실행되면 각 코드는 파일에서 지시자를 찾는다. 지시자는 #으로 시작해서 줄바꿈(개행)으로 끝나는 코드를 뜻한다.

|선행처리 지시자|설명|
|:--:|:--|
|#include|외부에 선언된 함수나 상수 등을 사용하기 위해, 함수나 상수가 포함된 외부 파일을 현재 파일에 포함할 때 사용|
|#define|함수나 단순화해주는 매크로를 정의할 때 사용|
|#undef|#define 지시자로 이미 정의된 매크로를 삭제할 때 사용|
|#line|__LINE__매크로와 __FILE__매크로를 재정의할 때 사용|
|#error|지정한 오류 메시지를 출력하고, 컴파일 과정을 중단하고자 할 때 사용|
|#pragma|프로그램의 이식성을 위해 운영체제별로 달라지는 지시사항을 컴파일에 전달할 때 사용|
|#if, #ifdef, #ifndef,<br>#elif, #else, #endif|조건부 컴파일 지시자|

#### 대표적인 선행처리 명령문

##### 1. 매크로 상수(젝트와 유사한 매크로(#define : Object-like macro))
* 매크로의 이름은 식별자가 매크로라는 사실을 부각시키기 위해 대문자로 정의한다.

```cpp
//지시자 매크로 매크로 몸체
#define  PI     3.1415		//매크로 PI를 매크로 몸체 3.1415로 전부 치환
```

##### 2. 매크로 함수(함수와 유사한 매크로(#define : Function-like macro))
* 매크로 함수는 정의할 때에는 매크로의 몸체부분을 구성하는 X와 같은 전달인자 전부 괄호를 해야 하고, 반드시 전체를 괄호로 한번 더 묶어줘야 한다.
* 매크로를 두 줄 이상에 걸쳐서 정의할 때에는 \문자를 활용해서 줄바꿈을 한다.

```cpp
//SQUARE(X) 입력 시 X*X형태로 전환(X는 매개변수)
#define SQUARE(X) ((X) * (X))	

//매크로를 줄바꿈
#define SQUARE(Y)  \ 
    ((Y) * (Y))	

/*잘못된 예시
//전달인자에 괄호를 안할 경우
SQUARE(3+2);	//3+2*3+2 = 11, 의도한 값 : 25

//전체 괄호를 안할 경우
int num = 120 / SQUARE(2);	// 120 / (2) * (2) = 120, 의도한 값 : 30
*/
```

* **매크로 함수의 장점**
    * 매크로 함수는 일반 함수에 비해 실행속도가 빠르다.
    * 자료형에 따라서 별도로 함수를 정의하지 않아도 된다.

* **매크로 함수의 단점**
    * 정의하기가 정말로 까다롭다.
    * 디버깅하기가 쉽지 않다.
    
* **매크로 함수의 실행속도가 빠른 이유**
    * 호출된 함수를 위한 스택 메모리의 할당
    * 실행위치의 이동과 매개변수로의 인자 전달
    * return 문에 의한 값의 반환
 
#### 조건부 컴파일을 위한 매크로
* 조건부 컴파일을 사용하면 지정한 조건에 따라 코드의 일정 부분을 컴파일할지 안 할지를 지정할 수 있다.
* #if 및 #ifdef 같은 모든 조건부 컴파일 지시문은 파일 종료 전에 닫는 #endif 지시문과 일치해야 한다.


##### 1.#if, #endif
* #if 전처리기 지시문은 조건식이 참이면 컴파일할 코드를 삽입하고 거짓이면 삭제한다.
* #endif 전처리기 지시문은 앞에 있는 조건부 컴파일을 닫는다.

```cpp
#include <stdio.h>
#define ADD	1
#define MIN	0

int main()
{
    #if ADD		//ADD가 '참'이라면 #endif 사이에 있는 코드를 삽입, 거짓이면 삭제
    	...
    #endif
    #if MIN		//MIN가 '참'이라면 #endif 사이에 있는 코드를 삽입, 거짓이면 삭제
    	...
    #endif
    
    return 0;
}
```

##### 2.#ifdef, #ifndef
* #ifdef 전처리기 지시문은 매크로가 정의되어 있다면 해당 매크로의 값에 상관없이 컴파일할 코드를 삽입한다.
* #ifndef 전처리기 지시문은 매크로가 정의되어 있지 않다면 해당 매크로의 값에 상관없이 컴파일할 코드를 삽입한다(#ifndef의 중간에 있는 n은 not을 의미).
* #ifndef..#endif는 헤더파일의 중복포함을 막기 위해 주로 사용한다.

```cpp
#include <stdio.h>
//#define ADD 1
#define MIN 0

int main()
{
    #ifdef ADD		//ADD가 정의되어 있지않으므로 #endif 사이에 있는 코드 삭제
        ...
    #endif
    #ifdef MIN		//MIN이 정의되어 있으므로 #endif 사이에 있는 코드 삽입
        ...
    #endif
    
    #ifndef ADD		//ADD가 정의되어 있지않으므로 #endif 사이에 있는 코드 삽입
        ...
    #endif
    #ifndef MIN		//MIN이 정의되어 있으므로 #endif 사이에 있는 코드 삭제
        ...
    #endif
    
    return 0;
}
```








