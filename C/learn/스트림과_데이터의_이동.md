스트림과 데이터의 이동
---
### 스트림
* '한 방향으로 흐르는 데이터의 흐름'을 뜻한다.
* **프로그램상에서 입출력 장치들을 대상으로 데이터를 입출력하기 하기 위해서는 이들을 연결시켜 주는 다리**가 필요하다.<br/>이러한 다리의 역할을 하는 매개체를 **'스트림(stream)'** 이라 한다.
* 운영체제는 외부장치와 프로그램과의 데이터 송수신의 도구가 되는 스트림을 제공하고 있다.

```cpp
stdin  //표준 입력 스트림  키보드 대상으로 입력
stdout //표준 출력 스트림  모니터 대상으로 출력
stdin  //표준 에러 스트림  모디터 대상으로 입력
```

#### 문자 출력 함수(putchar, fputc)
* **putchar 함수**는 인자로 전달된 문자정보를 stdout으로 표현되는 표준 출력 스트림으로 전송하는 함수이다.
* **fputc 함수**는 putchar함수와 같이 문자를 전송하는 함수이지만, **문자를 전송할 스트림을 지정**할 수 있다.<br/>stdout뿐만 아니라 **파일을 대상으로도 데이터를 전송**할 수 있다.

```cpp
#include <stdio.h>

//함수호출 성공 시 쓰여진 문자정보가, 실패 시 EOF 반환
int putchar(int c);
int fputc(int c, FILE* stream);	//fputc 함수의 두 번째 매개변수 stream은 문자를 출력할 스트림의 지정에 사용된다.
```

#### 문자 입력 함수(getchar, fgetc)
* **getchar 함수**는 stdin으로 표현되는 표준 입력 스트림으로부터 하나의 문자를 입력 받아서 반환하는 함수이다.
* **fgetc 함수**는 getchar함수와 같이 하나의 문자를 입력 받는 함수이지만, **문자를 입력 받을 스트림을 지정**할 수 있다.

```cpp
#include <stdio.h>

//파일의 끝에 도달하거나 함수호출 실패 시 EOF 반환
int getchar(void);
int fgetc(FILE* stream);
```

#### EOF(End Of File)
* 파일의 끝을 표현하기 위해서 정의해 놓은 상수
* **EOF을 반환하는 조건**
1) 함수호출의 실패
2) Windows에서 CTRL + Z 키, Linux에서 CTRL + D 키가 입력되는 경우
```cpp
int ch;

while (1)
{
	ch = getchar();
	if (ch == EOF)	//Windows에서 CTRL + Z 키 입력하면 ch = EOF
		break;
	putchar(ch);
}
```

#### 반환형이 int이고, int형 변수에 문자를 담는 이유
getchar 함수와 fgetc 함수가 반환하는 값 중 하나인 **EOF는 -1로 정의된 상수**이다.<br/>
따라서 반환형이 char형이라면, 그리고 char를 unsigned char로 처리하는 컴파일러에 의해서 컴파일이 되었다면,<br/>
EOF는 반환의 과정에서 엉뚱한 양의 정수로 형 변환이 되어버리고 만다. 그래서 **어떠한 상황에서도 -1을 인식할 수 있는 int형으로 반환형을 정의**해 놓은 것이다.

#### 문자 단위 입출력 함수의 존재 이유
**print**와 **scanf 함수**는 본래 서식지정을 통해서 **새로운 입출력의 형태를 구성하는 함수**이다.
이렇듯 화려한 기능을 제공하는 함수는 그에 따른 대가가 요구되어 사용하는 **메모리 공간도 크고, 해야 할 연산의 양도 많아서 상대적으로 속도가 느리다**.
뿐만 아니라 **별도의 서식지정을 해야 하니 문장을 구성하는 것도 번거로운 편**이다.
따라서 단순히 문자 하나를 입출력 하는 것이 목적이라면 **문자 입력함수와 문자 출력함수**를 사용하면 된다.

#### 문자열 출력 함수(puts,fputs)
* **puts 함수**가 호출되면 문자열 출력 후 **자동으로 개행이 이뤄**지지만, **fputs 함수**가 호출되면 **문자열 출력 후 자동으로 개행이 이뤄지지<br/> 않는다**.
```cpp
#include <stdio.h>

//성공 시 음수가 아닌 값을, 실패 시 EOF 반환
int puts(const char* s);
int fputs(const char* s, FILE* stream);
```
#### 문자열 입력 함수(gets, fgets)
* gets 함수는 미리 마련해 놓은 배열을 넘어서는 길이의 문자열이 입력되면, 할당 받지 않는 메모리 공간을 침범하여 실행 중 오류가<br/> 발생한다는 단점이 있다.
* fgets 함수는 stdin으로부터 문자열을 입력 받아서 sizeof(str)의 길이만큼만 배열 str에 저장한다.
```cpp
#include <stdio.h>

//파일의 끝에 도달하거나 함수호출 실패 시 NULL 포인터 반환
//char* gets(char* s);
//char* fgets(char* s, int n, FILE* stream);

char str[7];	//7바이트의 메모리 공간 할당
gets(str);		//입력 받은 문자열을 배열 str에 저장
fgets(str,sizeof(str),stdin);	//stdin으로부터 문자열 입력 받아서 str에 저장
...	
```
* 여기서도 문자열과 같이 문자열을 입력 받으면 문자열의 끝에 자동으로 널 문자가 추가된다.
* fgets 함수는 \n을 만날 때까지 문자열을 읽어 들이는데, \n을 제외시키거나 버리지 않고 문자열의 입부로 받아들인다(입력 한 엔터 키의<br/> 정보까지도 문자열의 일부로 저장).
```cpp
char str[7];
int i;

for(i = 0; i<3; i++)
{
	fgets(str, sizeof(str), stdin);
	printf("Read %d: %s \n", i + 1, str);
}
//여기서 fgets함수가 7보다 하나 작은 6의 길이만큼만 문자열을 읽는다.
//6글자 문자열이면 마지막 자리에 \n(개행)이 들어가고, 6글자 문자열을 초과하면 개행을 삽입하지 않고 7글자 문자열로 읽는다.
```

### 표준 입출력과 버퍼

#### 표준 입출력 함수
ANSI C의 표준에서 정의된 함수(printf, scanf, fputc, fgetc 등등). 표준 입출력 함수를 통해서 입출력한 데이터들은 운영체제가 제공하는<br/>'메모리 버퍼'를 중간에 통과하게 된다.
이 때 키보드로부터 입력된 데이터가 입력 스트림을 거쳐서 입력 버퍼로 들어가는 시점은 엔터키가<br/> 눌리는 시점이다.


* **메모리 버퍼** : 데이터를 임시로 모아두는(저장하는) 메모리 공간.
```
실행중인 프로그램 창에서
키보드(입력)-> 입력 스트림(통로) -> 입력 버퍼(엔터키) -> 실행중인 프로그램 ->
출력 스트림(통로) -> 출력 버퍼(출력) -> 모니터(화면에 표기)
```

* **버퍼링(Buffering)** <br/>
데이터를 목적지로 바로 전송하지 않고 중간에 출력버퍼와 입력버퍼를 둬서 전송하고자 하는 데이터를 임시 저장을 뜻함. 

* **데이터 버퍼링을 하는 이유** <br/>
가장 큰 이유는 '데이터 전송의 효율성'과 관련이 있다.
버퍼링 없이 키보드가 눌릴 때마다 눌린 문자의 정보를 목적지로 바로<br/> 이동시키는 것보다 중간에 메모리 버퍼를 둬서 데이터를 한데 묵어서 이동시키는 것이 보다 효율적이고 빠르다.





