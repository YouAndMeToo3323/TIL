포인터 
===

### 1. 변수 형태의 포인터
#### 포인터 변수
메모리의 주소 값을 저장하기 위한 변수.<br/>
```cpp
int* pnum;  //"ptr"이라는 변수를 선언하고, 이 변수가 정수를 가리킬 수 있는 포인터임을 나타낸다.

int*	  //포인터 변수를 선언할 때 사용하는 타입 지정자(int형 포인터)
pnum	  //포인터 변수의 이름(int형 포인터 변수 pnum)

//포인터 변수의 선언에 있어서 *연산자의 위치는 상관이 없다.
double * pnum1;
double* pnum1;
double *pnum1;
```

#### &연산자
'오른쪽에 등장하는 피연산자의 주소 값을 반환하는 연산자'이다. 따라서 &num은 변수num의 주소 값이 반환되며,<br/> 이를 포인터 변수 pnum에 저장한다.<br/>
`pnum = &num;`

#### *연산자
'포인터가 가리키는 메모리 공간에 접근할 때 사용하는 연산자'이다. 이를 **"간접 참조"** 또는 **"역참조"** 라고 한다.<br/>
`*pnum = 20;		//num = 20;(pnum = &num, *pnum이 가리키는 num의 저장된 값이 변경됨)`

#### 간접 참조에 대한 사용 및 이유
**1) 함수 호출 및 반환 값** <br/>
포인터를 사용하여 함수로부터 여러 값을 반환하거나 함수에 값을 전달할 수 있다.<br/> 함수 인수로 포인터를 사용하면 원래 변수를 수정할 수 있다.

**2) 동적 메모리 할당**<br/>
포인터를 사용하여 힙(heap) 메모리에서 동적으로 메모리를 할당하고 해제할 수 있다.<br/> 동적 할당을 통해 프로그램이 실행 중에 필요한 메모리를 동적으로 관리할 수 있다.

**3) 데이터 구조 및 배열**<br/>
포인터를 사용하여 배열의 요소 또는 데이터 구조의 멤버에 접근할 수 있다.<br/> 이것은 데이터 구조와 배열을 효율적으로 조작하는 데 도움이 된다.

**4) 메모리 조작** <br/>
포인터를 사용하여 메모리 주소를 직접 조작하고 데이터를 복사하거나 이동하는 데 사용할 수 있다.<br/> 이는 낮은 수준의 메모리 조작이 필요한 경우에 유용하다.

#### 포인트의 형(Type)
* int, char, double과 같이 변수의 선언 및 구분에 사용되는 키워드를 **'자료형'** 이라 하듯이 포인터 변수의 선언 및 구분에 사용되는<br/>int*, char*, double* 등을 가리켜 말한다.
* 포인터 변수도 값을 저장하는 변수이기 때문에 **'자료형'의 범주**에 포함된다.

```cpp
type*		//type형 포인터
type* ptr	//type형 포인터 변수 ptr
```
### 2.상수 형태의 포인터
#### 배열의 이름
* 포인터로서 그 값을 바꿀 수 없는 **'상수 형태의 포인터'** 이다. 배열의 이름도 포인터이기 때문에 배열의 이름을 피연산자로 하는 *연산이<br/> 가능.
* 1차원 배열이름의 포인터형은 배열의 이름이 가리키는 대상을 기준으로 결정.

|비교조건|포인터 변수|배열의 이름|
|-|-|-|
|이름이 존재하는가?|존재한다|존재한다|
|무엇을 나타내거나 저장하는가?|메모리의 주소 값|메모리의 주소 값|
|주소 값의 변경이 가능한가?|가능하다|불가능하다|

```cpp
int arr[i] : arr[i]는 int형 포인터 상수
&arr[i] : arr[i]에 대한 메모리의 주소값
arr[i] : arr[i]에 저장된 값
arr[i] == *(arr+i)	//arr[i]는 *(arr+i)와 같다.

ptr : ptr이 가리키는 대상에 대한 메모리의 주소값(ptr = &arr[i];)
*ptr : ptr이 가리키는 대상의 값(*ptr = arr[i];)

//포인터를 배열의 이름처럼 사용가능
*ptr = &arr[0];
ptr[0] = arr[0];
ptr[1] = arr[1];
...

*(ptr++) = 20;  //현재 ptr이 가리키는 위치(arr[0])에 20을 할당한 후 ptr을 1만큼 증가
*(++ptr) = 20;  //ptr을 1만큼 증가시킨 후, 그 위치(arr[1])에 20을 할당
*(ptr+1) =20;   //ptr에 저장된 값은 변경되지 않음
```

#### 두 가지 형태의 문자열 표현

```cpp
char str1[] = "My String";  //변수 형태의 문자열(상수형태의 포인터), 가리키는 대상을 변경할 수 없지만 문자열의 일부를 변경 가능
str1 = "Your String";       //문자열 변경 실패
str1[0] = 'B';              //호출한 문자열(배열)에 해당하는 값 변경

char* str2 = "Your String";  //상수 형태의 문자열(변수형태의 포인터), 가리키는 대상을 변경할 수 있지만 문자열의 일부를 변경 불가능 
str2 = "Our String";         //str2이 가리키는 대상을 문자열 "Our String"(주소값)으로 변경
str2[0] = 'T';               //문자열 일부(값) 변경 실패
```

#### 포인터 배열
포인터 변수로 이루어지고 주소 값의 저장이 가능한 배열을 말한다. 포인터 배열의 선언방식은 기본 자료형 배열의 선언방식과 동일하다.

```cpp
int* arr1[20];     //길이가 20인 int형 포인터 배열 arr1
double* arr2[30];  //길이가 30인 double형 포인터 배열 arr2

int num1 = 10, num2 = 20, num3 = 30;
int* arr[3] = { &num1, &num2, &num3 };  //포인터 배열 arr3에 선언한 변수의 주소값으로 선언 및 초기화
```

#### 문자열을 저장하는 포인터 배열
문자열의 주소 값을 저장할 수 있는 배열로서 사실상 **char형 포인터 배열**이다. 큰따옴표로 묶어서 표현되는 문자열은 그 형태에 상관없이 메모리 공간에 저장된 후 그 주소 값이 반환된다.

```cpp
char* strArr[3]={ "Simple", "String", "Array" };  //길이가 3인 char형 포인터 배열
```

#### 배열을 함수의 인자로 전달하는 방식
배열의 주소 값을 인자로 전달해서 접근하도록 유도하는 방법을 사용한다.

```cpp
void SimpleFunc(int* param){};
void OterFunc(int param[],int len){};

int main()
{
	int arr[3] = {1,2,3};
	int* ptr= arr;		//int형 포인터 변수를 이용해 배열의 형태로 접근할수 있도록 선언

	printf("%zd %zd\n", sizeof(ptr), sizeof(ptr)/sizeof(int));    //sizeof(ptr) = 8, 포인터 변수의 길이로 표기
	printf("%zd %zd\n", sizeof(arr), sizeof(arr) / sizeof(int));  //sizeof(arr) = 12, 배열의 길이로 표기

	SimpelFunc(ptr);    //함수를 호출하면서 배열의 주소 값 전달
	OterFunc(ptr,sizeof(ptr)/sizeof(int));    //함수를 호출하면서 배열의 주소 값 전달
}
```

* 배열의 길이를 계산해서 인자로 전달하는 이유<br/>
배열의 주소 값을 인자로 전달받은 매개변수는 **포인터 변수**이기 때문에 이를 대상으로 **sizeof 연산을 할 경우 배열의 크기가 반환되지 않고 포인터 변수의 크기가 반환된다**.<br/>그러므로 함수 내에서는 인자로 전달된 배열의 길이를 계산할 수가 없기 때문에 **배열의 크기나 길이정보도 함께 인자로 전달해야 한다**.




